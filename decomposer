#!/bin/bash

CWD=$( pwd )
TARGET_DIR=${TARGET_DIR:-/var/www/libs/}
SCRIPT_NAME=${0##*/}

usage() {
  cat << EOF
usage: ${SCRIPT_NAME} <command>

Manage a PHP project libraries
Rely on decomposer.json file in working directory

Commands:
  install    install all the libraries
             and generate an include file
  develop    same as install
             add an extra check to error out if include file is outdated
  help       display this message
EOF
}

error() {
  [[ -z "$1" ]] || printf '%s: %s\n' "${SCRIPT_NAME}" "$1"
  printf "Try '%s help' for more information.\\n" "${SCRIPT_NAME}"
  exit 1
} >&2

decomposer_install_library() {
  local name="$1"
  local object="$2"
  local status_text_variable="$3"

  local url=$( jq -r '.url' <<< "${object}" )
  local version=$( jq -r '.version' <<< "${object}" )

  local library_target_dir="${name}-${version}"
  if [ "$( jq 'has("target-dir")' <<< "${object}" )" = 'true' ]; then
    library_target_dir+=$( jq -r '."target-dir"' <<< "${object}" )
  fi

  cd "${TARGET_DIR}"

  if ! [ -d "${name}-${version}" ]; then
    if ! git clone "${url}" "${library_target_dir}" &> /dev/null; then
      printf -v "${status_text_variable}" 'cloning git repository failed'
      return 1
    fi

    local just_cloned=1
  fi

  if [ -h "${name}-${version}" ]; then
    printf -v "${status_text_variable}" 'symlink'
    return 2
  elif [ -f "${library_target_dir}/.git" ]; then
    printf -v "${status_text_variable}" 'git worktree'
    return 2
  elif ! [ -d "${library_target_dir}/.git" ]; then
    printf -v "${status_text_variable}" 'not a git repository'
    return 2
  fi

  cd "${library_target_dir}"

  if [ -z "${just_cloned}" ]; then
    # no need to fetch changes if we just cloned the repository
    if ! git fetch origin &> /dev/null; then
      printf -v "${status_text_variable}" 'fetching changes failed'
      return 1
    fi
  fi

  if [ "$( jq 'has("revision")' <<< "${object}" )" = 'true' ]; then
    local revision=$( jq -r '.revision' <<< "${object}" )
  else
    local revision="${version}"
  fi

  local revision_type=$( git cat-file -t "${revision}" 2> /dev/null )
  local revision_alt_type=$( git cat-file -t "v${revision}" 2> /dev/null )
  local revision_reset=

  if git branch -a | grep -q "/origin/${revision}"; then
    revision_reset="origin/${revision}"
  elif [ "${revision_type}" = 'commit' ] || [ "${revision_type}" = 'tag' ]; then
    revision_reset="${revision}"
  elif [ "${revision_alt_type}" = 'commit' ] || [ "${revision_alt_type}" = 'tag' ]; then
    revision_reset="v${revision}"
  fi

  if [ -z "${revision_reset}" ]; then
    printf -v "${status_text_variable}" "revision '%s' not found" "${revision}"
    return 1
  fi

  if [ "$( git rev-parse HEAD )" = "$( git rev-parse "${revision_reset}^{commit}" )" ]; then
    # do not reset local modifications to correct revision
    return 0
  fi

  if ! git reset --hard "${revision_reset}" &> /dev/null; then
    printf -v "${status_text_variable}" 'resetting changes failed'
    return 1
  fi
}

decomposer_create_library_autoload() {
  local name="$1"
  local object="$2"

  local version=$( jq -r '.version' <<< "${object}" )

  local library_target_dir="${name}-${version}"
  if [ "$( jq 'has("target-dir")' <<< "${object}" )" = 'true' ]; then
    library_target_dir+=$( jq -r '."target-dir"' <<< "${object}" )
  fi

  cd "${TARGET_DIR}"

  if [ "$( jq 'has("psr0")' <<< "${object}" )" = 'true' ]; then
    local psr0_path=$( jq -r '.psr0.path' <<< "${object}" )

    cat << EOF > "${name}-${version}.php"
<?php

set_include_path(
    get_include_path() . ':' .
    __DIR__ . '/${name}-${version}${psr0_path}'
);

?>
EOF
  elif [ "$( jq 'has("psr4")' <<< "${object}" )" = 'true' ]; then
    local psr4_prefix=$( jq -r '.psr4.prefix' <<< "${object}" )
    local psr4_path=$( jq -r '.psr4."search-path"' <<< "${object}" )

    cat << EOF > "${name}-${version}.php"
<?php

autoload_register_psr4_prefix('${psr4_prefix}', '${name}-${version}${psr4_path}');

?>
EOF
  fi
}

decomposer_process_file() {
  local file="$1"

  local libraries_names=$( jq -r ".|to_entries|map(.key|tostring)|.[]" "${file}" )

  for name in ${libraries_names}; do
    local status_text
    local object=$( jq ".\"${name}\"" "${file}")

    printf 'Installing %s...' "${name}"

    decomposer_install_library "${name}" "${object}" status_text

    case "$?" in
      0) printf 'done\n' ;;
      1) printf 'failed (%s)\n' "${status_text}" ;;
      2) printf 'skipped (%s)\n' "${status_text}" ;;
    esac

    decomposer_create_library_autoload "${name}" "${object}"
  done
}

md5checksum() {
  local file="$1"

  case "$( uname )" in
    'Linux')
      md5sum "${file}" | cut -f1 -d' '
      ;;
    'Darwin')
      md5 -q "${file}"
      ;;
  esac
}

decomposer_create_project_autoload() {
  local file="$1"
  local include_outdated_check="$2"

  local libraries=$( jq -r ".|to_entries|map(.key|tostring)|.[]" "${file}" )
  local autoload="${CWD}/decomposer.autoload.inc.php"

  printf '<?php\n\n' > "${autoload}"

  if [ -n "${include_outdated_check}" ]; then
    local md5=$( md5checksum "${CWD}/decomposer.json" )

    cat << EOF >> "${autoload}"
if (md5_file(__DIR__ . '/decomposer.json') != '${md5}')
{
    die("Decomposer autoload file is outdated. Please re-run 'decomposer develop'
");
}

EOF
  fi

  for library in ${libraries}; do
    local version=$( jq -r ".\"${library}\".version" "${file}" )

    printf "require_once '%s-%s.php';\\n" "${library}" "${version}" >> "${autoload}"
  done

  printf '\n?>\n' >> "${autoload}"
}

validate_inputs() {
  if ! [ -f "${CWD}/decomposer.json" ]; then
    error 'No decomposer.json found.'
  fi

  if ! [ -d "${TARGET_DIR}" ] || ! [ -w "${TARGET_DIR}" ]; then
    error "TARGET_DIR '${TARGET_DIR}' is not a writable directory."
  fi
}

decomposer_run() {
  local include_outdated_check="$1"

  validate_inputs
  decomposer_process_file "${CWD}/decomposer.json"
  decomposer_create_project_autoload "${CWD}/decomposer.json" "${include_outdated_check}"
}

COMMAND="$1"

case "${COMMAND}" in
  'install')
    decomposer_run
    ;;
  'develop')
    decomposer_run include_outdated_check
    ;;
  'help')
    usage
    exit
    ;;
  '')
    error 'Missing command'
    ;;
  *)
    error 'Invalid command'
esac
