#!/usr/bin/env bash

CWD=$( pwd )
TARGET_DIR=${TARGET_DIR:-/var/www/libs/}
SCRIPT_NAME=${0##*/}

usage() {
  cat << EOF
usage: ${SCRIPT_NAME} <command>

Manage a PHP project libraries
Rely on decomposer.json file in working directory

Commands:
  install    install all the libraries
             and generate an include file
  develop    same as install
             add an extra check to error out if include file is outdated
  help       display this message
EOF
}

error() {
  [[ -z "$1" ]] || printf '%s: %s\n' "${SCRIPT_NAME}" "$1"
  printf "Try '%s help' for more information.\\n" "${SCRIPT_NAME}"
  exit 1
} >&2

decomposer_install_library() {
  local name="$1"
  local object="$2"
  local status_text_variable="$3"

  local url version library_target_dir

  url=$( jq -r '.url' <<< "${object}" )
  version=$( jq -r '.version' <<< "${object}" )

  library_target_dir="${name}-${version}"
  if [ "$( jq 'has("target-dir")' <<< "${object}" )" = 'true' ]; then
    library_target_dir+=$( jq -r '."target-dir"' <<< "${object}" )
  fi

  cd "${TARGET_DIR}" || return 2

  if ! [ -d "${name}-${version}" ]; then
    if ! git clone "${url}" "${library_target_dir}" &> /dev/null; then
      printf -v "${status_text_variable}" 'cloning git repository failed'
      return 1
    fi

    local just_cloned=1
  fi

  if [ -h "${name}-${version}" ]; then
    printf -v "${status_text_variable}" 'symlink'
    return 2
  elif [ -f "${library_target_dir}/.git" ]; then
    printf -v "${status_text_variable}" 'git worktree'
    return 2
  elif ! [ -d "${library_target_dir}/.git" ]; then
    printf -v "${status_text_variable}" 'not a git repository'
    return 2
  fi

  cd "${library_target_dir}" || return 2

  if [ -z "${just_cloned}" ]; then
    # no need to fetch changes if we just cloned the repository
    if ! git fetch origin &> /dev/null; then
      printf -v "${status_text_variable}" 'fetching changes failed'
      return 1
    fi
  fi

  local revision revision_type revision_alt_type revision_reset

  if [ "$( jq 'has("revision")' <<< "${object}" )" = 'true' ]; then
    revision=$( jq -r '.revision' <<< "${object}" )
  else
    revision="${version}"
  fi

  revision_type=$( git cat-file -t "${revision}" 2> /dev/null )
  revision_alt_type=$( git cat-file -t "v${revision}" 2> /dev/null )
  revision_reset=

  if git branch -a | grep -q "/origin/${revision}"; then
    revision_reset="origin/${revision}"
  elif [ "${revision_type}" = 'commit' ] || [ "${revision_type}" = 'tag' ]; then
    revision_reset="${revision}"
  elif [ "${revision_alt_type}" = 'commit' ] || [ "${revision_alt_type}" = 'tag' ]; then
    revision_reset="v${revision}"
  fi

  if [ -z "${revision_reset}" ]; then
    printf -v "${status_text_variable}" "revision '%s' not found" "${revision}"
    return 1
  fi

  if [ "$( git rev-parse HEAD )" = "$( git rev-parse "${revision_reset}^{commit}" )" ]; then
    # do not reset local modifications to correct revision
    return 0
  fi

  if ! git reset --hard "${revision_reset}" &> /dev/null; then
    printf -v "${status_text_variable}" 'resetting changes failed'
    return 1
  fi
}

decomposer_create_library_autoload() {
  local name="$1"
  local object="$2"

  local version library_target_dir

  version=$( jq -r '.version' <<< "${object}" )

  library_target_dir="${name}-${version}"
  if [ "$( jq 'has("target-dir")' <<< "${object}" )" = 'true' ]; then
    library_target_dir+=$( jq -r '."target-dir"' <<< "${object}" )
  fi

  cd "${TARGET_DIR}" || return 1

  local psr0_path psr4_prefix psr4_path

  if [ "$( jq 'has("psr0")' <<< "${object}" )" = 'true' ]; then
    psr0_path=$( jq -r '.psr0.path' <<< "${object}" )

    cat << EOF > "${name}-${version}.php"
<?php

set_include_path(
    get_include_path() . ':' .
    __DIR__ . '/${name}-${version}${psr0_path}'
);

?>
EOF
  elif [ "$( jq 'has("psr4")' <<< "${object}" )" = 'true' ]; then
    psr4_prefix=$( jq -r '.psr4.prefix' <<< "${object}" )
    psr4_path=$( jq -r '.psr4."search-path"' <<< "${object}" )

    cat << EOF > "${name}-${version}.php"
<?php

autoload_register_psr4_prefix('${psr4_prefix}', '${name}-${version}${psr4_path}');

?>
EOF
  fi
}

decomposer_process_file() {
  local file="$1"

  local libraries_names status_text object

  libraries_names=$( jq -r ".|to_entries|map(.key|tostring)|.[]" "${file}" )

  for name in ${libraries_names}; do
    object=$( jq ".\"${name}\"" "${file}")

    printf 'Installing %s...' "${name}"

    if ! decomposer_validate_library "${object}" status_text; then
      printf 'failed (invalid definition: %s)\n' "${status_text}"
      continue
    fi

    decomposer_install_library "${name}" "${object}" status_text

    case "$?" in
      0) printf 'done\n' ;;
      1) printf 'failed (%s)\n' "${status_text}" ;;
      2) printf 'skipped (%s)\n' "${status_text}" ;;
    esac

    decomposer_create_library_autoload "${name}" "${object}"
  done
}

decomposer_validate_library() {
  local object="$1"
  local status_text_variable="$2"
  local conditions

  conditions="(type == \"object\")"
  conditions="$conditions and (.url|type == \"string\")"
  conditions="$conditions and (.version|type == \"string\")"
  conditions="$conditions and (if has(\"revision\") then (.revision|type == \"string\") else true end)"
  conditions="$conditions and (if has(\"target-dir\") then (.\"target-dir\"|type == \"string\") else true end)"
  conditions="$conditions and ((has(\"psr0\") or has(\"psr4\")) and (has(\"psr0\") and has(\"psr4\") | not))"
  conditions="$conditions and (if has(\"psr0\") then (.psr0.\"path\"|type == \"string\") else true end)"
  conditions="$conditions and (if has(\"psr4\") then (.psr4.\"prefix\"|type == \"string\") and (.psr4.\"search-path\"|type == \"string\") else true end)"

  if [ "$( jq -r "$conditions" <<< "${object}")" = 'true' ]; then
    return 0
  fi

  if ! [ "$( jq -r type <<< "${object}" )" = 'object' ]; then
    printf -v "${status_text_variable}" 'not an object'
    return 1
  fi

  if ! [ "$( jq -r '.url|type' <<< "${object}" )" = 'string' ]; then
    printf -v "${status_text_variable}" 'invalid url'
    return 1
  fi

  if ! [ "$( jq -r '.version|type' <<< "${object}" )" = 'string' ]; then
    printf -v "${status_text_variable}" 'invalid version'
    return 1
  fi

  if [ "$( jq 'has("revision")' <<< "${object}" )" = 'true' ] \
    && ! [ "$( jq -r '.revision|type' <<< "${object}" )" = 'string' ]; then
    printf -v "${status_text_variable}" 'invalid revision'
    return 1
  fi

  if [ "$( jq 'has("target-dir")' <<< "${object}" )" = 'true' ] \
    && ! [ "$( jq -r '."target-dir"|type' <<< "${object}" )" = 'string' ]; then
    printf -v "${status_text_variable}" 'invalid target-dir'
    return 1
  fi

  local has_psr0 has_psr4

  has_psr0=$( jq 'has("psr0")' <<< "${object}" )
  has_psr4=$( jq 'has("psr4")' <<< "${object}" )

  if [ "${has_psr0}" = 'false' ] && [ "${has_psr4}" = 'false' ]; then
    printf -v "${status_text_variable}" 'missing psr0 or psr4'
    return 1
  fi

  if [ "${has_psr0}" = 'true' ] && [ "${has_psr4}" = 'true' ]; then
    printf -v "${status_text_variable}" 'conflicting psr0 and psr4'
    return 1
  fi

  if [ "${has_psr0}" = 'true' ]; then
    if ! [ "$( jq -r '.psr0."path"|type' <<< "${object}" )" = 'string' ]; then
      printf -v "${status_text_variable}" 'invalid psr0'
      return 1
    fi
  elif [ "${has_psr4}" = 'true' ]; then
    if ! [ "$( jq -r '.psr4."prefix"|type' <<< "${object}" )" = 'string' ] \
      || ! [ "$( jq -r '.psr4."search-path"|type' <<< "${object}" )" = 'string' ]; then
      printf -v "${status_text_variable}" 'invalid psr4'
      return 1
    fi
  fi
}

md5checksum() {
  local file="$1"

  case "$( uname )" in
    'Linux')
      md5sum "${file}" | cut -f1 -d' '
      ;;
    'Darwin')
      md5 -q "${file}"
      ;;
  esac
}

decomposer_create_project_autoload() {
  local file="$1"
  local include_outdated_check="$2"

  local libraries autoload md5 version

  libraries=$( jq -r ".|to_entries|map(.key|tostring)|.[]" "${file}" )
  autoload="${CWD}/decomposer.autoload.inc.php"

  printf '<?php\n\n' > "${autoload}"

  if [ -n "${include_outdated_check}" ]; then
    md5=$( md5checksum "${CWD}/decomposer.json" )

    cat << EOF >> "${autoload}"
if (md5_file(__DIR__ . '/decomposer.json') != '${md5}')
{
    die("Decomposer autoload file is outdated. Please re-run 'decomposer develop'
");
}

EOF
  fi

  for library in ${libraries}; do
    if [ "$( jq -r ".\"${library}\".\"version\"|type" "${file}" )" = 'string' ]; then
      version=$( jq -r ".\"${library}\".version" "${file}" 2> /dev/null )
      printf "require_once '%s-%s.php';\\n" "${library}" "${version}" >> "${autoload}"
    fi
  done

  printf '\n?>\n' >> "${autoload}"
}

validate_inputs() {
  if ! [ -f "${CWD}/decomposer.json" ]; then
    error 'No decomposer.json found.'
  fi

  if ! [ -d "${TARGET_DIR}" ] || ! [ -w "${TARGET_DIR}" ]; then
    error "TARGET_DIR '${TARGET_DIR}' is not a writable directory."
  fi

  if ! [ "$( jq -r type "${CWD}/decomposer.json" 2> /dev/null )" = 'object' ]; then
    error 'decomposer.json is not a valid JSON object'
  fi
}

decomposer_run() {
  local include_outdated_check="$1"

  validate_inputs
  decomposer_process_file "${CWD}/decomposer.json"
  decomposer_create_project_autoload "${CWD}/decomposer.json" "${include_outdated_check}"
}

COMMAND="$1"

case "${COMMAND}" in
  'install')
    decomposer_run
    ;;
  'develop')
    decomposer_run include_outdated_check
    ;;
  'help')
    usage
    exit
    ;;
  '')
    error 'Missing command'
    ;;
  *)
    error 'Invalid command'
esac
