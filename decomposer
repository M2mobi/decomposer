#!/usr/bin/env bash

CWD=$( pwd )
TARGET_DIR=${TARGET_DIR:-/var/www/libs/}
SCRIPT_NAME=${0##*/}
GENERATE_CHANGELOG=0
CHANGELOG_FILE=${CWD}/decomposer.diffnotes.md
INCLUDE_OUTDATED_CHECK=1

usage() {
  cat << EOF
usage: ${SCRIPT_NAME} <command> [<options>]

Manage a PHP project libraries
Rely on decomposer.json file in working directory

Commands:
  install    install all the libraries and generate an include file
             -c --changelog [FILE] generate a changelog from last installation
             --no-dev              meant for installation on production environment
  help       display this message
EOF
}

error() {
  [[ -z "$1" ]] || printf '%s: %s\n' "${SCRIPT_NAME}" "$1"
  printf "Try '%s help' for more information.\\n" "${SCRIPT_NAME}"
  exit 1
} >&2

decomposer_install_library() {
  local name="$1"
  local object="$2"
  local status_text_variable="$3"

  local url version library_target_dir

  url=$( jq -r '.url' <<< "${object}" )
  version=$( jq -r '.version' <<< "${object}" )

  library_target_dir=$( jq -r '."target-dir"' <<< "${object}" )
  if [ "${library_target_dir}" = "null" ]; then
    library_target_dir="${name}-${version}"
  else
    library_target_dir="${name}-${version}${library_target_dir}"
  fi

  cd "${TARGET_DIR}" || return 2

  if ! [ -d "${name}-${version}" ]; then
    if ! git clone "${url}" "${library_target_dir}" &> /dev/null; then
      printf -v "${status_text_variable}" 'cloning git repository failed'
      return 1
    fi

    local just_cloned=1
  fi

  if [ -h "${name}-${version}" ]; then
    printf -v "${status_text_variable}" 'symlink'
    return 2
  elif [ -f "${library_target_dir}/.git" ]; then
    printf -v "${status_text_variable}" 'git worktree'
    return 2
  elif ! [ -d "${library_target_dir}/.git" ]; then
    printf -v "${status_text_variable}" 'not a git repository'
    return 2
  fi

  cd "${library_target_dir}" || return 2

  local revision revision_type revision_alt_type revision_reset

  revision=$( jq -r '.revision' <<< "${object}" )
  if [ "${revision}" = "null" ]; then
    revision="${version}"
  fi

  revision_type=$( git cat-file -t "${revision}" 2> /dev/null )
  revision_alt_type=$( git cat-file -t "v${revision}" 2> /dev/null )
  revision_reset=

  if git branch -a | grep -q "/origin/${revision}"; then
    revision_reset="origin/${revision}"
  elif [ "${revision_type}" = 'commit' ] || [ "${revision_type}" = 'tag' ]; then
    revision_reset="${revision}"
  elif [ "${revision_alt_type}" = 'commit' ] || [ "${revision_alt_type}" = 'tag' ]; then
    revision_reset="v${revision}"
  fi

  if [ -z "${just_cloned}" ] && [ "${revision_reset}" = "origin/${revision}" ] || [ -z "${revision_reset}" ]; then
    # no need to fetch changes if we just cloned the repository
    # or we can already resolve a commit or tag
    if ! git fetch origin &> /dev/null; then
      printf -v "${status_text_variable}" 'fetching changes failed'
      return 1
    fi
  fi

  if [ -z "$revision_reset" ]; then
    revision_type=$( git cat-file -t "${revision}" 2> /dev/null )
    revision_alt_type=$( git cat-file -t "v${revision}" 2> /dev/null )
    revision_reset=

    if git branch -a | grep -q "/origin/${revision}"; then
      revision_reset="origin/${revision}"
    elif [ "${revision_type}" = 'commit' ] || [ "${revision_type}" = 'tag' ]; then
      revision_reset="${revision}"
    elif [ "${revision_alt_type}" = 'commit' ] || [ "${revision_alt_type}" = 'tag' ]; then
      revision_reset="v${revision}"
    fi
  fi

  if [ -z "${revision_reset}" ]; then
    printf -v "${status_text_variable}" "revision '%s' not found" "${revision}"
    return 1
  fi

  if [ "$( git rev-parse HEAD )" = "$( git rev-parse "${revision_reset}^{commit}" )" ]; then
    # do not reset local modifications to correct revision
    return 0
  fi

  if ! git reset --hard "${revision_reset}" &> /dev/null; then
    printf -v "${status_text_variable}" 'resetting changes failed'
    return 1
  fi

  if [ "${GENERATE_CHANGELOG}" == 1 ]; then
    decomposer_write_changelog
  fi
}

decomposer_write_changelog() {
  local base
  base=$( git reflog | head -n 2 | tail -n 1 | cut -d " " -f 1 )

  printf "# %s:\n" "${name}"
  printf "## Added:\n"
  git cherry -v "${base}" HEAD | cut -d " " -f 3-
  printf "\n## Removed:\n"
  git cherry -v HEAD "${base}" | cut -d " " -f 3-
  printf "\n"
} >> "${CHANGELOG_FILE}"

decomposer_create_library_autoload() {
  local name="$1"
  local object="$2"

  local version library_target_dir

  version=$( jq -r '.version' <<< "${object}" )

  library_target_dir=$( jq -r '."target-dir"' <<< "${object}" )
  if [ "${library_target_dir}" = "null" ]; then
    library_target_dir="${name}-${version}"
  else
    library_target_dir="${name}-${version}${library_target_dir}"
  fi

  cd "${TARGET_DIR}" || return 1

  local psr0_path psr4_prefix psr4_path

  if [ "$( jq 'has("psr0")' <<< "${object}" )" = 'true' ]; then
    psr0_path=$( jq -r '.psr0.path' <<< "${object}" )

    cat << EOF > "${name}-${version}.php"
<?php

set_include_path(
    get_include_path() . ':' .
    __DIR__ . '/${name}-${version}${psr0_path}'
);

?>
EOF
  elif [ "$( jq 'has("psr4")' <<< "${object}" )" = 'true' ]; then
    if [ "$( jq -r '.psr4|type' <<< "${object}" )" = 'object' ]; then
      psr4_prefix=$( jq -r '.psr4.prefix' <<< "${object}" )
      psr4_path=$( jq -r '.psr4."search-path"' <<< "${object}" )

    cat << EOF > "${name}-${version}.php"
<?php

autoload_register_psr4_prefix('${psr4_prefix}', '${name}-${version}${psr4_path}');

?>
EOF
    else
      printf '<?php\n\n' > "${name}-${version}.php"

      for psr4_config in $( jq -c '.psr4[]' <<< "${object}" ); do
        psr4_prefix=$( jq -r '.prefix' <<< "${psr4_config}" )
        psr4_path=$( jq -r '."search-path"' <<< "${psr4_config}" )
        echo "autoload_register_psr4_prefix('${psr4_prefix}', '${name}-${version}${psr4_path}');" \
          >> "${name}-${version}.php"
      done

      printf '\n?>' >> "${name}-${version}.php"
    fi
  fi
}

decomposer_process_file() {
  local file="$1"

  local libraries_names status_text object

  libraries_names=$( jq -r ".|to_entries|map(.key|tostring)|.[]" "${file}" )

  for name in ${libraries_names}; do
    object=$( jq ".\"${name}\"" "${file}")

    printf 'Installing %s...' "${name}"

    if ! decomposer_validate_library "${object}" status_text; then
      printf 'failed (invalid definition: %s)\n' "${status_text}"
      continue
    fi

    decomposer_install_library "${name}" "${object}" status_text

    case "$?" in
      0) printf 'done\n' ;;
      1) printf 'failed (%s)\n' "${status_text}" ;;
      2) printf 'skipped (%s)\n' "${status_text}" ;;
    esac

    decomposer_create_library_autoload "${name}" "${object}"
  done
}

decomposer_validate_library() {
  local object="$1"
  local status_text_variable="$2"
  local conditions

  conditions="(type == \"object\")"
  conditions="$conditions and (.url|type == \"string\")"
  conditions="$conditions and (.version|type == \"string\")"
  conditions="$conditions and (if has(\"revision\") then (.revision|type == \"string\") else true end)"
  conditions="$conditions and (if has(\"target-dir\") then (.\"target-dir\"|type == \"string\") else true end)"
  conditions="$conditions and ((has(\"psr0\") or has(\"psr4\")) and (has(\"psr0\") and has(\"psr4\") | not))"

  if [ "$( jq -r "$conditions" <<< "${object}")" = 'true' ]; then
    return 0
  fi

  if ! [ "$( jq -r type <<< "${object}" )" = 'object' ]; then
    printf -v "${status_text_variable}" 'not an object'
    return 1
  fi

  if ! [ "$( jq -r '.url|type' <<< "${object}" )" = 'string' ]; then
    printf -v "${status_text_variable}" 'invalid url'
    return 1
  fi

  if ! [ "$( jq -r '.version|type' <<< "${object}" )" = 'string' ]; then
    printf -v "${status_text_variable}" 'invalid version'
    return 1
  fi

  if [ "$( jq 'has("revision")' <<< "${object}" )" = 'true' ] \
    && ! [ "$( jq -r '.revision|type' <<< "${object}" )" = 'string' ]; then
    printf -v "${status_text_variable}" 'invalid revision'
    return 1
  fi

  if [ "$( jq 'has("target-dir")' <<< "${object}" )" = 'true' ] \
    && ! [ "$( jq -r '."target-dir"|type' <<< "${object}" )" = 'string' ]; then
    printf -v "${status_text_variable}" 'invalid target-dir'
    return 1
  fi

  local has_psr0 has_psr4

  has_psr0=$( jq 'has("psr0")' <<< "${object}" )
  has_psr4=$( jq 'has("psr4")' <<< "${object}" )

  if [ "${has_psr0}" = 'false' ] && [ "${has_psr4}" = 'false' ]; then
    printf -v "${status_text_variable}" 'missing psr0 or psr4'
    return 1
  fi

  if [ "${has_psr0}" = 'true' ] && [ "${has_psr4}" = 'true' ]; then
    printf -v "${status_text_variable}" 'conflicting psr0 and psr4'
    return 1
  fi
}

md5checksum() {
  local file="$1"

  case "$( uname )" in
    'Linux')
      md5sum "${file}" | cut -f1 -d' '
      ;;
    'Darwin')
      md5 -q "${file}"
      ;;
  esac
}

decomposer_create_project_autoload() {
  local file="$1"

  local libraries autoload md5 version

  libraries=$( jq -r ".|to_entries|map(.key|tostring)|.[]" "${file}" )
  autoload="${CWD}/decomposer.autoload.inc.php"

  printf '<?php\n\n' > "${autoload}"

  if [ "${INCLUDE_OUTDATED_CHECK}" == 1 ]; then
    md5=$( md5checksum "${CWD}/decomposer.json" )

    cat << EOF >> "${autoload}"
if (md5_file(__DIR__ . '/decomposer.json') != '${md5}')
{
    die("Decomposer autoload file is outdated. Please re-run 'decomposer install'");
}

EOF
  fi

  for library in ${libraries}; do
    if [ "$( jq -r ".\"${library}\".\"version\"|type" "${file}" )" = 'string' ]; then
      version=$( jq -r ".\"${library}\".version" "${file}" 2> /dev/null )
      printf "require_once '%s-%s.php';\\n" "${library}" "${version}" >> "${autoload}"
    fi
  done

  printf '\n?>\n' >> "${autoload}"
}

validate_inputs() {
  if ! [ -f "${CWD}/decomposer.json" ]; then
    error 'No decomposer.json found.'
  fi

  if ! [ -d "${TARGET_DIR}" ] || ! [ -w "${TARGET_DIR}" ]; then
    error "TARGET_DIR '${TARGET_DIR}' is not a writable directory."
  fi

  if ! [ "$( jq -r type "${CWD}/decomposer.json" 2> /dev/null )" = 'object' ]; then
    error 'decomposer.json is not a valid JSON object'
  fi

  # Clear changelog and test write
  if [ "${GENERATE_CHANGELOG}" == 1 ]; then
    if ! printf '' 2> /dev/null > "${CHANGELOG_FILE}"; then
      error "Changelog file '${CHANGELOG_FILE}' is not writable."
    fi
  fi
}

decomposer_run() {
  validate_inputs
  decomposer_process_file "${CWD}/decomposer.json"
  decomposer_create_project_autoload "${CWD}/decomposer.json"

  if [ "${GENERATE_CHANGELOG}" == 1 ]; then
    printf "\nWrote changelog to %s\n" "${CHANGELOG_FILE}"
  fi
}

parse_arguments() {
  COMMAND=$1
  shift
  while [ "$#" -gt 0 ]; do
    case "$1" in
      "-c" | "--changelog")
        GENERATE_CHANGELOG=1
        if [ -n "$2" ] && [ ${2:0:1} != "-" ]; then
          case "$2" in
            /*) CHANGELOG_FILE="$2" ;;
            *) CHANGELOG_FILE="${CWD}/$2" ;;
          esac
          shift
        fi
        ;;
      "--no-dev")
        INCLUDE_OUTDATED_CHECK=0
        ;;
      *)
        printf "Unknown option %s\n" "$1"
        if [ -n "$2" ] && [ ${2:0:1} != "-" ]; then
          shift
        fi
        ;;
    esac
    shift
  done

  case "${COMMAND}" in
    'install')
      decomposer_run
      ;;
    'help')
      usage
      exit
      ;;
    '')
      error 'Missing command'
      ;;
    *)
      error 'Invalid command'
  esac
}

parse_arguments "$@"
